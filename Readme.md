Лабораторная работа №9 по курсу NoSQL.

Задание:
	- Придумать 2-3 варианта, когда применима графовая база данных. Можно даже абзац на контекст каждого примера.
	-Воспользоваться моделью, данными и командами из лекции или одним из своих примеров из пункта 1 и реализовать аналог в любой выбранной БД (реляционной или нет - на выбор). Сравнить команды.
Написать, что удобнее было сделать в выбранной БД, а что в Neo4j и привести примеры.

Решение:

1) На мой взгляд графовая БД применима для решения следующих задач:
а) Для решения задачи по выбору контрагентов на исполнения договора услуг ЮЛ. А именно, когда ЮЛ с какой-от периодичностью проводит тендеры (например, раз в год) на определенные услуги (например, клининг офисов, поставка канцтоваров и подобная хозяйственная и нехозяйственная деятельность), то всегда ведется учет с кем был заключен договор и результаты этого договора (устроило-ли выполнение поставщиков обязательство по договору и прочее). Графовая БД позволит наглядно отобразить зависимость заявившихся на тендер ЮЛ от их собственников. А также позволит увидеть такие ситуации когда два ЮЛ заявившихся на тендер имеют одних и тех же учредителей, что может оказаться существенным обстоятельством для отказа от выбора победителя тендера. А так же исключить конфликт интересов между ЮЛ заказчика и ЮЛ подрядчика, в случае если работник ЮЛ заказчика является учредителем ЮЛ подрядчика.

б) Для решения задач по исключению конфликта интересов между работниками ЮЛ. А именно, когда в ЮЛ работает сотрудник на ключевой должности (от руководителя отдела и выше) и в его непосредственное подчинение устраивается родственник (как ближний, так и дальний), то возможен риск конфликта интересов. Для исключения этого риска можно принимать нового сотрудника в другое подразделение, а графовая БД позволит наглядно увидеть отображение родственных связей.

2)
neo4j:
//Заносим данные о сотруднике
- create (:Employee {name: 'Иванов Иван Иванович', department: 'Financier', title: 'Head of financier'})

//Заносим данные о родственниках сотрудника
- create (:Relative {name: 'Иванова Ксения Владимировна'})
- create (:Relative {name: 'Петров Владимир Владиславович'})
- create (:Relative {name: 'Петрова Ирина Александровна'})
- create (:Relative {name: 'Смирнов Алексей Александрович'})
- create (:Relative {name: 'Смирнов Алена Владимировна'})

//Добавляем связи
- match (main:Employee {name:'Иванов Иван Иванович'})
  match (subj:Relative {name:'Иванова Ксения Владимировна'})
  create (main) -[:Супруг]-> (subj)

- match (main:Relative {name:'Иванова Ксения Владимировна'})
  match (subj:Relative {name: 'Петров Владимир Владиславович'})
  create (main) -[:Отец]-> (subj)

- match (main:Relative {name:'Иванова Ксения Владимировна'})
  match (subj:Relative {name: 'Петрова Ирина Александровна'})
  create (main) -[:Мать]-> (subj)
  
- match (main:Relative {name:'Петрова Ирина Александровна'})
  match (subj:Relative {name: 'Смирнов Алексей Александрович'})
  create (main) -[:Сестра]-> (subj)
  
- match (main:Relative {name:'Смирнов Алексей Александрович'})
  match (subj:Relative {name: 'Смирнов Алена Владимировна'})
  create (main) -[:Супруг]-> (subj)

//Заносим данные о соискателе
- create (:Applicant {name: 'Смирнов Петр Алексеевич', department: 'Financier', title: 'Financier'})

//Заносим связи с родственними соискателя
- match (main:Applicant {name: 'Смирнов Петр Алексеевич'})
  match (subj:Relative {name: 'Смирнов Алексей Александрович'})
  create (main) -[:Отец]-> (subj)
  
- match (main:Applicant {name: 'Смирнов Петр Алексеевич'})
  match (subj:Relative {name: 'Смирнов Алена Владимировна'})
  create (main) -[:Мать]-> (subj)

//Выбираем пересечения с вложенностью до 3 уровня
match (main:Employee {name: 'Иванов Иван Иванович'}) -[*1..5]- (subj:Applicant {name: 'Смирнов Петр Алексеевич'}) return subj

//В результате получаем ноду соискателя

//Приложение:
Рисунок 1 - построенный граф 
Рисунок 2 - результат выболнения выборки пересечения

PostgreSQL:
Для решения подобной задачи в реляционной БД нам понадобится:
- Таблица, где будут хранится данные о физическом лице
- Таблица, где будут хранится родственные связи физических лиц
- Таблица, где будет хранится информация о соискатели и сотруднике
- Представление, которое будет собирать все родственные связи в цепочку и искать пересечение

Вывод:
Решение этой задачи (поиск пересечения) было удобно сделать в графовой БД. 
Если изменится входящее условие (поиск пересечения глубиной 8, вместо 5), то изменение условия запроса в графовой БД будет менее затратно чет в реляционной.
Язык Cypher не так удобед и понятен как SQL в реляционной БД, но спишу это на привычку.
Графовая БД идеально подходит для решения задач по поиску пересечений, для этого потребуется гораздо меньше кода. Но при продуктивном решении задачи, 
графовая БД будет дополнительной к основной реляционной. Т.е. все данные будут хранится в реляционной БД и перегружаться в графовую для решения задачи.

P.S.
Все имена вымышленные, совпадения с реальными людьми случайность:)
